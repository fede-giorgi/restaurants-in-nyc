# Data

## Setup and Data loading

This section installs required packages and loads the dataset directly from the NYC Open Data API.

```{r}
# ==============================================================================
# SETUP & DEPENDENCIES 
# ==============================================================================
packages <- c(
  "tidyverse",
  "ggdensity",
  "lubridate",
  "dplyr",
  "purrr",
  "sf",
  "ggplot2"
  )

new_packages <- packages[!(packages %in% installed.packages()[, "Package"])]

if (length(new_packages) > 0) {
  install.packages(new_packages)
}

invisible(lapply(packages, library, character.only = TRUE))

# ==============================================================================
# VISUALIZATION THEME 
# ==============================================================================
theme_nyc <- function() {
  theme_minimal(base_family = "sans") +
    theme(
      # Typography: Bold "Newspaper Headline" style or Subway Signage
      plot.title = element_text(face = "bold", size = 18, color = "#121212", margin = margin(b = 10)),
      plot.subtitle = element_text(size = 12, color = "#444444", margin = margin(b = 15)),
      plot.caption = element_text(size = 9, color = "#666666", face = "italic"),
      
      # Axes: Strong and dark for structure
      axis.title = element_text(face = "bold", size = 11, color = "#121212"),
      axis.text = element_text(size = 10, color = "#222222"),
      
      # Grid: "The NYC Grid" (clean, thin major lines)
      panel.grid.major = element_line(color = "#e0e0e0", linewidth = 0.5),
      panel.grid.minor = element_blank(), # Remove minor grid lines to reduce visual noise
      
      # Legend and Layout
      legend.position = "top", # Position top for immediate readability
      legend.title = element_text(face = "bold", size = 10),
      legend.text = element_text(size = 10),
      
      # Facet Strips (Headers for multi-panel plots)
      strip.text = element_text(face = "bold", size = 11, hjust = 0),
      strip.background = element_rect(fill = "transparent", color = NA)
    )
}

# ==============================================================================
# DATA INGESTION (API)
# ==============================================================================

# Define the remote URL to ensure reproducibility
url_dati <- "https://data.cityofnewyork.us/api/views/43nn-pn8j/rows.csv?accessType=DOWNLOAD"

# Load the dataset directly from the web
df <- read_csv(url_dati,
    # Enforce specific column types to handle parsing issues upfront
    col_types = cols(
    .default = col_character(),
    CAMIS = col_double(),
    ZIPCODE = col_character(),
    SCORE = col_double(),
    Latitude = col_double(),
    Longitude = col_double(),
    `Community Board` = col_double(),
    BIN = col_double(),
    BBL = col_double()
  ),
  show_col_types = FALSE
 ) |>
  # Parse date columns from string (Month-Day-Year) to Date objects
  mutate(`INSPECTION DATE` = mdy(`INSPECTION DATE`),
         `GRADE DATE` = mdy(`GRADE DATE`),
         `RECORD DATE` = mdy(`RECORD DATE`))
```

## Missing value analysis

Missing values are predominantly found in GRADE and GRADE DATE, both exceeding 50%. This reflects the inspection workflow, where a numeric score is assigned immediately, but a letter grade is often deferred until a re-inspection or final decision.

```{r}
# Calculate percentage of missing values per column
missing_summary <- df |>
  summarise(across(everything(), ~ mean(is.na(.)) * 100)) |>
  pivot_longer(everything(), names_to = "column", values_to = "percent_missing") |>
  filter(percent_missing > 0.1) |> # Filter only columns with missing values
  arrange(desc(percent_missing))

# Bar chart
ggplot(missing_summary, aes(x = reorder(column, percent_missing), y = percent_missing)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(title = "Percentage of Missing Values by Column",
       x = "Variable", 
       y = "% Missing") +
  theme_nyc()
```

Expanding on the column-wise analysis, the heatmap reveals the operational workflow behind the missing values. While Pattern 1 represents finalized inspections (complete data), Pattern 2 is nearly as frequent and accounts for the large gap between missing Scores and missing Grades. Additionally, Pattern 3 (missing both Score and Grade) likely isolates administrative or non-graded interactions, distinct from standard sanitary inspections

```{r}
# 1. Create patterns
missing_patterns <- df |>
  select(GRADE, `GRADE DATE`, SCORE, `VIOLATION CODE`, `ACTION`) |>
  mutate(across(everything(), is.na)) |>
  group_by(across(everything())) |>
  summarise(count = n(), .groups = "drop") |>
  arrange(desc(count)) |>
  ungroup() |>
  mutate(pattern_id = row_number()) |>
  pivot_longer(cols = -c(count, pattern_id), names_to = "variable", values_to = "is_missing")

# 2. Prepare data for plotting (Top 10 only)
top_patterns <- missing_patterns |>
  filter(pattern_id <= 10) |>
  # Create a descriptive Y-axis label including the count
  mutate(row_label = paste0("Pattern ", pattern_id, " (n = ", count, ")"))

# 3. Visualization
ggplot(top_patterns, aes(x = variable, y = fct_rev(fct_inorder(row_label)), fill = is_missing)) +
  geom_tile(color = "white") +
  
  # Manual colors: Orange for Missing, Grey for Present
  scale_fill_manual(values = c("TRUE" = "tomato", "FALSE" = "grey80"), 
                    labels = c("Present", "Missing")) +
  
  # English labels
  labs(title = "Common Missing Value Patterns",
       subtitle = "Which columns tend to be missing together? (Top 10 Patterns)",
       x = "Variable", 
       y = "Pattern Frequency", 
       fill = "Is Missing?") +
  
  theme_nyc()

```

## Restaurant-level aggregation and cuisine grouping

To shift our focus from individual inspections to the restaurants themselves, we restructure the dataset. By grouping records under each unique CAMIS identifier, we generate a comprehensive profile for every venue. This allows us to average hygiene scores over time and categorize establishments into broader culinary traditions for clearer visualization.

```{r}
# ==============================================================================
# DATA AGGREGATION AT RESTAURANT LEVEL 
# ==============================================================================

# Helper functions to handle NAs safely
last_non_null <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 0) return(NA)
  tail(x, 1)
}

safe_mean <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 0) return(NA_real_)
  mean(x)
}

restaurants <- df |>
  # Remove dummy dates (1900) and focus on relevant recent data (post-2015)
  filter(`INSPECTION DATE` >= ymd("2015-01-01")) |> 
  
  arrange(`INSPECTION DATE`) |>
  group_by(CAMIS) |>
  summarise(
    DBA      = first(na.omit(DBA)),
    BORO     = first(na.omit(BORO)),
    BUILDING = first(BUILDING),
    STREET   = first(STREET),
    ZIPCODE  = first(ZIPCODE),
    PHONE    = first(PHONE),
    CUISINE_DESCRIPTION = first(`CUISINE DESCRIPTION`),
    
    # If the first value is NA, the mean retrieves the location across inspections
    Latitude  = mean(Latitude, na.rm = TRUE), 
    Longitude = mean(Longitude, na.rm = TRUE),

    n_inspections    = n_distinct(`INSPECTION DATE`, na.rm = TRUE),
    first_inspection = min(`INSPECTION DATE`, na.rm = TRUE),
    last_inspection  = max(`INSPECTION DATE`, na.rm = TRUE),

    mean_score = safe_mean(SCORE),
    # Mean score provides a good summary of overall hygiene performance
    
    last_grade = last_non_null(GRADE),

    # Create a list of all unique violations ever received by the restaurant
    violations = list(unique(na.omit(`VIOLATION DESCRIPTION`))),
    .groups = "drop"
  )

# ==============================================================================
# CUISINE CATEGORIZATION MAPPING 
# ==============================================================================

mapping <- c(
  # --- AMERICAN (Include ora Seafood, Jewish/Kosher e varianti regionali) ---
  "American"                       = "American",
  "New American"                   = "American",
  "Chicken"                        = "American",
  "Hamburgers"                     = "American",
  "Steakhouse"                     = "American",
  "Barbecue"                       = "American",
  "Hotdogs"                        = "American",
  "Hotdogs/Pretzels"               = "American",
  "Soul Food"                      = "American",
  "Continental"                    = "American",
  "Californian"                    = "American",
  "Southwestern"                   = "American",
  "Cajun"                          = "American",
  "Creole"                         = "American",
  "Creole/Cajun"                   = "American",
  "Hawaiian"                       = "American", # Poke Ã¨ spesso fast casual
  "Seafood"                        = "American", # Unito ad American
  "Jewish/Kosher"                  = "American", # Unito ad American (stile Deli)

  # --- CAFE, DELI, BAKERY & DESSERTS (Include Sandwiches e Salads) ---
  "Coffee/Tea"                     = "Cafe/Deli/Bakery",
  "Bakery Products/Desserts"       = "Cafe/Deli/Bakery",
  "Donuts"                         = "Cafe/Deli/Bakery",
  "Frozen Desserts"                = "Cafe/Deli/Bakery",
  "Pancakes/Waffles"               = "Cafe/Deli/Bakery",
  "Nuts/Confectionary"             = "Cafe/Deli/Bakery",
  "Fruits/Vegetables"              = "Cafe/Deli/Bakery",
  # Spostati qui come richiesto:
  "Sandwiches"                     = "Cafe/Deli/Bakery",
  "Sandwiches/Salads/Mixed Buffet" = "Cafe/Deli/Bakery",
  "Salads"                         = "Cafe/Deli/Bakery",
  "Soups/Salads/Sandwiches"        = "Cafe/Deli/Bakery",
  "Soups"                          = "Cafe/Deli/Bakery",
  "Juice, Smoothies, Fruit Salads" = "Cafe/Deli/Bakery",
  "Bagels/Pretzels"                = "Cafe/Deli/Bakery",
  "Bottled Beverages"              = "Cafe/Deli/Bakery",

  # --- ASIAN ---
  "Chinese"                        = "Asian",
  "Japanese"                       = "Asian",
  "Asian/Asian Fusion"             = "Asian",
  "Korean"                         = "Asian",
  "Thai"                           = "Asian",
  "Southeast Asian"                = "Asian",
  "Bangladeshi"                    = "Asian",
  "Filipino"                       = "Asian",
  "Pakistani"                      = "Asian",
  "Chinese/Japanese"               = "Asian",
  "Chinese/Cuban"                  = "Asian",
  "Indonesian"                     = "Asian",
  "Afghan"                         = "Asian",
  
  # --- LATIN AMERICAN ---
  "Mexican"                        = "Latin American",
  "Latin American"                 = "Latin American",
  "Caribbean"                      = "Latin American",
  "Tex-Mex"                        = "Latin American",
  "Peruvian"                       = "Latin American",
  "Brazilian"                      = "Latin American",
  "Chilean"                        = "Latin American",
  "Chimichurri"                    = "Latin American",
  
  # --- ITALIAN (Include Pizza) ---
  "Pizza"                          = "Italian",
  "Italian"                        = "Italian",
  
  # --- EUROPEAN (Spagnola, Est Europa, ecc.) ---
  "Spanish"                        = "European",
  "Irish"                          = "European",
  "Eastern European"               = "European",
  "Russian"                        = "European",
  "Polish"                         = "European",
  "German"                         = "European",
  "English"                        = "European",
  "Tapas"                          = "European",
  "Portuguese"                     = "European",
  "Czech"                          = "European",
  "Scandinavian"                   = "European",
  "Basque"                         = "European",
  "Armenian"                       = "European",

  # --- FRENCH ---
  "French"                         = "French",
  "New French"                     = "French",
  "Haute Cuisine"                  = "French",

  # --- MEDITERRANEAN / MIDDLE EASTERN ---
  "Mediterranean"                  = "Mediterranean/Middle Eastern",
  "Middle Eastern"                 = "Mediterranean/Middle Eastern",
  "Greek"                          = "Mediterranean/Middle Eastern",
  "Turkish"                        = "Mediterranean/Middle Eastern",
  "Falafel"                        = "Mediterranean/Middle Eastern",
  "Egyptian"                       = "Mediterranean/Middle Eastern",
  "Moroccan"                       = "Mediterranean/Middle Eastern",
  "Lebanese"                       = "Mediterranean/Middle Eastern",
  "Iranian"                        = "Mediterranean/Middle Eastern",

  # --- INDIAN ---
  "Indian"                         = "Indian",

  # --- OTHER ---
  "Other"                          = "Other",
  "Fusion"                         = "Other",
  "Australian"                     = "Other",
  "Polynesian"                     = "Other",
  "Not Listed/Not Applicable"      = "Other",
  "African"                        = "Other",
  "Ethiopian"                      = "Other"
)

# mapping
restaurants <- restaurants |>
  mutate(
    cuisine_group = mapping[CUISINE_DESCRIPTION],
    cuisine_group = ifelse(is.na(cuisine_group), "Other", cuisine_group)
  )
``` 
