{
  "hash": "4a87d8a2e7d3408405de94affe940bf9",
  "result": {
    "engine": "knitr",
    "markdown": "# Data\n\n## Setup and Data loading\n\nThis section installs required packages and loads the dataset directly from the NYC Open Data API.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ==============================================================================\n# SETUP & DEPENDENCIES \n# ==============================================================================\npackages <- c(\n  \"tidyverse\",\n  \"ggdensity\",\n  \"lubridate\",\n  \"dplyr\",\n  \"purrr\",\n  \"sf\",\n  \"ggplot2\"\n  )\n\nnew_packages <- packages[!(packages %in% installed.packages()[, \"Package\"])]\n\nif (length(new_packages) > 0) {\n  install.packages(new_packages)\n}\n\ninvisible(lapply(packages, library, character.only = TRUE))\n\n# ==============================================================================\n# VISUALIZATION THEME \n# ==============================================================================\ntheme_nyc <- function() {\n  theme_minimal(base_family = \"sans\") +\n    theme(\n      # Typography: Bold \"Newspaper Headline\" style or Subway Signage\n      plot.title = element_text(face = \"bold\", size = 18, color = \"#121212\", margin = margin(b = 10)),\n      plot.subtitle = element_text(size = 12, color = \"#444444\", margin = margin(b = 15)),\n      plot.caption = element_text(size = 9, color = \"#666666\", face = \"italic\"),\n      \n      # Axes: Strong and dark for structure\n      axis.title = element_text(face = \"bold\", size = 11, color = \"#121212\"),\n      axis.text = element_text(size = 10, color = \"#222222\"),\n      \n      # Grid: \"The NYC Grid\" (clean, thin major lines)\n      panel.grid.major = element_line(color = \"#e0e0e0\", linewidth = 0.5),\n      panel.grid.minor = element_blank(), # Remove minor grid lines to reduce visual noise\n      \n      # Legend and Layout\n      legend.position = \"top\", # Position top for immediate readability\n      legend.title = element_text(face = \"bold\", size = 10),\n      legend.text = element_text(size = 10),\n      \n      # Facet Strips (Headers for multi-panel plots)\n      strip.text = element_text(face = \"bold\", size = 11, hjust = 0),\n      strip.background = element_rect(fill = \"transparent\", color = NA)\n    )\n}\n\n# ==============================================================================\n# DATA INGESTION (API)\n# ==============================================================================\n\n# Define the remote URL to ensure reproducibility\nurl_dati <- \"https://data.cityofnewyork.us/api/views/43nn-pn8j/rows.csv?accessType=DOWNLOAD\"\n\n# Load the dataset directly from the web\ndf <- read_csv(url_dati,\n    # Enforce specific column types to handle parsing issues upfront\n    col_types = cols(\n    .default = col_character(),\n    CAMIS = col_double(),\n    ZIPCODE = col_character(),\n    SCORE = col_double(),\n    Latitude = col_double(),\n    Longitude = col_double(),\n    `Community Board` = col_double(),\n    BIN = col_double(),\n    BBL = col_double()\n  ),\n  show_col_types = FALSE\n ) |>\n  # Parse date columns from string (Month-Day-Year) to Date objects\n  mutate(`INSPECTION DATE` = mdy(`INSPECTION DATE`),\n         `GRADE DATE` = mdy(`GRADE DATE`),\n         `RECORD DATE` = mdy(`RECORD DATE`))\n```\n:::\n\n\n## Missing value analysis\n\nMissing values are predominantly found in GRADE and GRADE DATE, both exceeding 50%. This reflects the inspection workflow, where a numeric score is assigned immediately, but a letter grade is often deferred until a re-inspection or final decision.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate percentage of missing values per column\nmissing_summary <- df |>\n  summarise(across(everything(), ~ mean(is.na(.)) * 100)) |>\n  pivot_longer(everything(), names_to = \"column\", values_to = \"percent_missing\") |>\n  filter(percent_missing > 0.1) |> # Filter only columns with missing values\n  arrange(desc(percent_missing))\n\n# Bar chart\nggplot(missing_summary, aes(x = reorder(column, percent_missing), y = percent_missing)) +\n  geom_col(fill = \"steelblue\") +\n  coord_flip() +\n  labs(title = \"Percentage of Missing Values by Column\",\n       x = \"Variable\", \n       y = \"% Missing\") +\n  theme_nyc()\n```\n\n::: {.cell-output-display}\n![](data_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nExpanding on the column-wise analysis, the heatmap reveals the operational workflow behind the missing values. While Pattern 1 represents finalized inspections (complete data), Pattern 2 is nearly as frequent and accounts for the large gap between missing Scores and missing Grades. Additionally, Pattern 3 (missing both Score and Grade) likely isolates administrative or non-graded interactions, distinct from standard sanitary inspections\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Create patterns\nmissing_patterns <- df |>\n  select(GRADE, `GRADE DATE`, SCORE, `VIOLATION CODE`, `ACTION`) |>\n  mutate(across(everything(), is.na)) |>\n  group_by(across(everything())) |>\n  summarise(count = n(), .groups = \"drop\") |>\n  arrange(desc(count)) |>\n  ungroup() |>\n  mutate(pattern_id = row_number()) |>\n  pivot_longer(cols = -c(count, pattern_id), names_to = \"variable\", values_to = \"is_missing\")\n\n# 2. Prepare data for plotting (Top 10 only)\ntop_patterns <- missing_patterns |>\n  filter(pattern_id <= 10) |>\n  # Create a descriptive Y-axis label including the count\n  mutate(row_label = paste0(\"Pattern \", pattern_id, \" (n = \", count, \")\"))\n\n# 3. Visualization\nggplot(top_patterns, aes(x = variable, y = fct_rev(fct_inorder(row_label)), fill = is_missing)) +\n  geom_tile(color = \"white\") +\n  \n  # Manual colors: Orange for Missing, Grey for Present\n  scale_fill_manual(values = c(\"TRUE\" = \"tomato\", \"FALSE\" = \"grey80\"), \n                    labels = c(\"Present\", \"Missing\")) +\n  \n  # English labels\n  labs(title = \"Common Missing Value Patterns\",\n       subtitle = \"Which columns tend to be missing together? (Top 10 Patterns)\",\n       x = \"Variable\", \n       y = \"Pattern Frequency\", \n       fill = \"Is Missing?\") +\n  \n  theme_nyc()\n```\n\n::: {.cell-output-display}\n![](data_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## Restaurant-level aggregation and cuisine grouping\n\nTo shift our focus from individual inspections to the restaurants themselves, we restructure the dataset. By grouping records under each unique CAMIS identifier, we generate a comprehensive profile for every venue. This allows us to average hygiene scores over time and categorize establishments into broader culinary traditions for clearer visualization.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ==============================================================================\n# DATA AGGREGATION AT RESTAURANT LEVEL \n# ==============================================================================\n\n# Helper functions to handle NAs safely\nlast_non_null <- function(x) {\n  x <- x[!is.na(x)]\n  if (length(x) == 0) return(NA)\n  tail(x, 1)\n}\n\nsafe_mean <- function(x) {\n  x <- x[!is.na(x)]\n  if (length(x) == 0) return(NA_real_)\n  mean(x)\n}\n\nrestaurants <- df |>\n  # Remove dummy dates (1900) and focus on relevant recent data (post-2015)\n  filter(`INSPECTION DATE` >= ymd(\"2015-01-01\")) |> \n  \n  arrange(`INSPECTION DATE`) |>\n  group_by(CAMIS) |>\n  summarise(\n    DBA      = first(na.omit(DBA)),\n    BORO     = first(na.omit(BORO)),\n    BUILDING = first(BUILDING),\n    STREET   = first(STREET),\n    ZIPCODE  = first(ZIPCODE),\n    PHONE    = first(PHONE),\n    CUISINE_DESCRIPTION = first(`CUISINE DESCRIPTION`),\n    \n    # If the first value is NA, the mean retrieves the location across inspections\n    Latitude  = mean(Latitude, na.rm = TRUE), \n    Longitude = mean(Longitude, na.rm = TRUE),\n\n    n_inspections    = n_distinct(`INSPECTION DATE`, na.rm = TRUE),\n    first_inspection = min(`INSPECTION DATE`, na.rm = TRUE),\n    last_inspection  = max(`INSPECTION DATE`, na.rm = TRUE),\n\n    mean_score = safe_mean(SCORE),\n    # Mean score provides a good summary of overall hygiene performance\n    \n    last_grade = last_non_null(GRADE),\n\n    # Create a list of all unique violations ever received by the restaurant\n    violations = list(unique(na.omit(`VIOLATION DESCRIPTION`))),\n    .groups = \"drop\"\n  )\n\n# ==============================================================================\n# CUISINE CATEGORIZATION MAPPING \n# ==============================================================================\n\nmapping <- c(\n  # --- AMERICAN (Include ora Seafood, Jewish/Kosher e varianti regionali) ---\n  \"American\"                       = \"American\",\n  \"New American\"                   = \"American\",\n  \"Chicken\"                        = \"American\",\n  \"Hamburgers\"                     = \"American\",\n  \"Steakhouse\"                     = \"American\",\n  \"Barbecue\"                       = \"American\",\n  \"Hotdogs\"                        = \"American\",\n  \"Hotdogs/Pretzels\"               = \"American\",\n  \"Soul Food\"                      = \"American\",\n  \"Continental\"                    = \"American\",\n  \"Californian\"                    = \"American\",\n  \"Southwestern\"                   = \"American\",\n  \"Cajun\"                          = \"American\",\n  \"Creole\"                         = \"American\",\n  \"Creole/Cajun\"                   = \"American\",\n  \"Hawaiian\"                       = \"American\", # Poke Ã¨ spesso fast casual\n  \"Seafood\"                        = \"American\", # Unito ad American\n  \"Jewish/Kosher\"                  = \"American\", # Unito ad American (stile Deli)\n\n  # --- CAFE, DELI, BAKERY & DESSERTS (Include Sandwiches e Salads) ---\n  \"Coffee/Tea\"                     = \"Cafe/Deli/Bakery\",\n  \"Bakery Products/Desserts\"       = \"Cafe/Deli/Bakery\",\n  \"Donuts\"                         = \"Cafe/Deli/Bakery\",\n  \"Frozen Desserts\"                = \"Cafe/Deli/Bakery\",\n  \"Pancakes/Waffles\"               = \"Cafe/Deli/Bakery\",\n  \"Nuts/Confectionary\"             = \"Cafe/Deli/Bakery\",\n  \"Fruits/Vegetables\"              = \"Cafe/Deli/Bakery\",\n  # Spostati qui come richiesto:\n  \"Sandwiches\"                     = \"Cafe/Deli/Bakery\",\n  \"Sandwiches/Salads/Mixed Buffet\" = \"Cafe/Deli/Bakery\",\n  \"Salads\"                         = \"Cafe/Deli/Bakery\",\n  \"Soups/Salads/Sandwiches\"        = \"Cafe/Deli/Bakery\",\n  \"Soups\"                          = \"Cafe/Deli/Bakery\",\n  \"Juice, Smoothies, Fruit Salads\" = \"Cafe/Deli/Bakery\",\n  \"Bagels/Pretzels\"                = \"Cafe/Deli/Bakery\",\n  \"Bottled Beverages\"              = \"Cafe/Deli/Bakery\",\n\n  # --- ASIAN ---\n  \"Chinese\"                        = \"Asian\",\n  \"Japanese\"                       = \"Asian\",\n  \"Asian/Asian Fusion\"             = \"Asian\",\n  \"Korean\"                         = \"Asian\",\n  \"Thai\"                           = \"Asian\",\n  \"Southeast Asian\"                = \"Asian\",\n  \"Bangladeshi\"                    = \"Asian\",\n  \"Filipino\"                       = \"Asian\",\n  \"Pakistani\"                      = \"Asian\",\n  \"Chinese/Japanese\"               = \"Asian\",\n  \"Chinese/Cuban\"                  = \"Asian\",\n  \"Indonesian\"                     = \"Asian\",\n  \"Afghan\"                         = \"Asian\",\n  \n  # --- LATIN AMERICAN ---\n  \"Mexican\"                        = \"Latin American\",\n  \"Latin American\"                 = \"Latin American\",\n  \"Caribbean\"                      = \"Latin American\",\n  \"Tex-Mex\"                        = \"Latin American\",\n  \"Peruvian\"                       = \"Latin American\",\n  \"Brazilian\"                      = \"Latin American\",\n  \"Chilean\"                        = \"Latin American\",\n  \"Chimichurri\"                    = \"Latin American\",\n  \n  # --- ITALIAN (Include Pizza) ---\n  \"Pizza\"                          = \"Italian\",\n  \"Italian\"                        = \"Italian\",\n  \n  # --- EUROPEAN (Spagnola, Est Europa, ecc.) ---\n  \"Spanish\"                        = \"European\",\n  \"Irish\"                          = \"European\",\n  \"Eastern European\"               = \"European\",\n  \"Russian\"                        = \"European\",\n  \"Polish\"                         = \"European\",\n  \"German\"                         = \"European\",\n  \"English\"                        = \"European\",\n  \"Tapas\"                          = \"European\",\n  \"Portuguese\"                     = \"European\",\n  \"Czech\"                          = \"European\",\n  \"Scandinavian\"                   = \"European\",\n  \"Basque\"                         = \"European\",\n  \"Armenian\"                       = \"European\",\n\n  # --- FRENCH ---\n  \"French\"                         = \"French\",\n  \"New French\"                     = \"French\",\n  \"Haute Cuisine\"                  = \"French\",\n\n  # --- MEDITERRANEAN / MIDDLE EASTERN ---\n  \"Mediterranean\"                  = \"Mediterranean/Middle Eastern\",\n  \"Middle Eastern\"                 = \"Mediterranean/Middle Eastern\",\n  \"Greek\"                          = \"Mediterranean/Middle Eastern\",\n  \"Turkish\"                        = \"Mediterranean/Middle Eastern\",\n  \"Falafel\"                        = \"Mediterranean/Middle Eastern\",\n  \"Egyptian\"                       = \"Mediterranean/Middle Eastern\",\n  \"Moroccan\"                       = \"Mediterranean/Middle Eastern\",\n  \"Lebanese\"                       = \"Mediterranean/Middle Eastern\",\n  \"Iranian\"                        = \"Mediterranean/Middle Eastern\",\n\n  # --- INDIAN ---\n  \"Indian\"                         = \"Indian\",\n\n  # --- OTHER ---\n  \"Other\"                          = \"Other\",\n  \"Fusion\"                         = \"Other\",\n  \"Australian\"                     = \"Other\",\n  \"Polynesian\"                     = \"Other\",\n  \"Not Listed/Not Applicable\"      = \"Other\",\n  \"African\"                        = \"Other\",\n  \"Ethiopian\"                      = \"Other\"\n)\n\n# mapping\nrestaurants <- restaurants |>\n  mutate(\n    cuisine_group = mapping[CUISINE_DESCRIPTION],\n    cuisine_group = ifelse(is.na(cuisine_group), \"Other\", cuisine_group)\n  )\n```\n:::\n\n",
    "supporting": [
      "data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}